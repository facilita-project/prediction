'use strict'

const auth = require('./auth')
const debug = require('debug')
const Raven = require('raven')
const env = require('sugar-env')
const express = require('express')
const routes = require('./routes')
const server = require('./server')
const { inspect } = require('util')
const merge = require('lodash.merge')
const middlewares = require('./middlewares')
const { Error, HttpError, ValidationError } = require('./errors')

const ERR_RAVEN = 'unable to log the following error'
const ERR_SENTRY_SKIPED = 'initialization has been skipped'

/**
 * @param  {Function} fn Domain API factory.
 * @return {Function}    Application factory method.
 */
const factory = (fn) => {
  /**
   * @param  {Object} options     Configurations object from config.js file.
   * @param  {String} environment Current environment name.
   * @return {Object}             Instance of express app.
   */
  return (options, environment) => {

    if (environment !== env.TEST) {
      process.on('unhandledRejection', (reason, promise) => {
        if (Raven.installed) {
          Raven.captureException(reason)
        }

        console.error(reason)
      })
    }

    const config = merge({
      deeptrace: {
        dsn: env.get('DEEPTRACE_DSN'),
        shouldSendCallback: () => true,
        timeout: parseInt(env.get('DEEPTRACE_TIMEOUT', 3000)),
        tags: {
          environment,
          service: env.get('DEEPTRACE_TAGS_SERVICE', options.name),
          commit: env.get(['DEEPTRACE_TAGS_COMMIT', 'GIT_COMMIT']),
          release: env.get(['DEEPTRACE_TAGS_RELEASE', 'GIT_RELEASE'])
        }
      },
      morgan: {
        format: ':method :url :status :: :response-time ms :: :res[deeptrace-id]',
        skip: (req, res) => environment !== 'development'
      },
      sentry: {
        environment,
        autoBreadcrumbs: true,
        dsn: env.get('SENTRY_DSN'),
        name: env.get('SENTRY_NAME', options.name),
        release: env.get(['SENTRY_RELEASE', 'GIT_RELEASE']),
        sendTimeout: parseInt(env.get('SENTRY_TIMEOUT', 3)),
        shouldSendCallback: () => environment === 'production',
        tags: {
          git_commit: env.get(['SENTRY_TAGS_GIT_COMMIT', 'GIT_COMMIT'])
        }
      }
    }, options)

    if (config.sentry.dsn) {
      Raven.config(config.sentry.dsn, config.sentry)
           .install()

      Raven.on('error', ({ reason, statusCode, response }) => {
        debug('sentry:agent')(ERR_RAVEN, inspect({ reason, statusCode, response }))
      })
    }

    if (!Raven.installed) {
      debug('sentry:middleware')(ERR_SENTRY_SKIPED)
    }

    const app = express()

    app.use(middlewares.deeptrace.factory(config.deeptrace))
    app.use(middlewares.morgan.factory(config.morgan))
    app.use(middlewares.parsers.urlencoded.factory())
    app.use(middlewares.sentry.requests.factory())
    app.use(middlewares.parsers.json.factory())
    app.use(middlewares.helmet.factory())

    app.get('/ping', routes.ping.factory(config, environment))

    fn(app, config, environment)

    app.use('*', middlewares.routes.unmatched.factory())
    app.use(middlewares.validation.error.factory())
    app.use(middlewares.sentry.errors.factory())
    app.use(middlewares.stderr.factory())
    app.use(middlewares.normalizer.factory())
    app.use(middlewares.renderer.factory())

    return app
  }
}

module.exports = factory
module.exports.auth = auth
module.exports.Error = Error
module.exports.server = server
module.exports.factory = factory
module.exports.HttpError = HttpError
module.exports.ValidationError = ValidationError
module.exports.validate = middlewares.validation.schema.factory
